#include "IRremote.h"
#include "IRremoteInt.h"

// Reverse engineered by looking at RAW dumps generated by IRremote

//==============================================================================
//                   H   H  EEEEE   AAA   TTTTT  EEEEE  RRRR
//                   H   H  E      A   A    T    E      R   R
//                   HHHHH  EEE    AAAAA    T    EEE    RRRR
//                   H   H  E      A   A    T    E      R   R
//                   H   H  EEEEE  A   A    T    EEEEE  R   R
//==============================================================================
//~~> Heater Controls for Dr. Heater, Duraflame, Quartz Zone Heaters) <~~
// Added by Adam L. Humphreys

#define HEATER_BITS          12  // The number of bits in the command

// In reality, each bit seems to consistently be the difference between a mark and a space
// with an oddball ending or implied space, so I equated 10100110100101010101011 to 110110000001. 
// No distinct header.

#define HEATER_GOT_ONE     (results->rawbuf[offset] > 21 && results->rawbuf[offset] < 29)  // 1's ; 1100-1400
#define HEATER_GOT_ZERO    (results->rawbuf[offset] > 4 && results->rawbuf[offset] < 13)   // 0's ; 250-600

#define HEATER_BIT_ONE     1250  // The length of a Bit for 1's
#define HEATER_BIT_ZERO     400  // The length of a Bit for 0's

//+=============================================================================
//  <<<Some Codes>>>
//  Duraflame or Quartz Zone Heater Controls:
//
//  Function:    	Dec: 	Hex: 	Binary:
//  Power:        	3457,	0xD81,	110110000001
//  Flame / Time:	3472,	0xD90,	110110010000
//  Heat / Up ^ :	3464,	0xD88,	110110001000
//  >|| / Down v:	3460,	0xD84,	110110000100
//
//
//  Dr. Heater Controls:
//
//  Function:		Dec: 	Hex: 	Binary:
//  Mode/Power: 	3464,	0xD88,	110110001000
//  OSC/Mode:   	3523,	0xDC3,	110111000011
//  Timer :  		3488,	0xDA0,	110110100000
//  Heat +:  		3472,	0xD90,	110110010000
//  Heat -:  		3460,	0xD84,	110110000100
//  Humidifer:		3526,	0xDC6,	110111000110
//  Twice repeated
//  end code:		3456,	0xD80,	110110000000 (Doesnâ€™t seem necessary.)

//+=============================================================================
//
#if SEND_HEATER
void  IRsend::sendHeater (unsigned long data,  int nbits)
{
	// Must be sent at least twice with a delay of ~8ms between sends.
	
	// Set IR carrier frequency
	enableIROut(38);

	// Data
	unsigned short odd = 1;
	for (unsigned long  mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
		if (data & mask) {
			mark (HEATER_BIT_ONE);
			space(HEATER_BIT_ZERO);
		} else {
			mark (HEATER_BIT_ZERO);
			space(HEATER_BIT_ONE);
		}
	}

    space(0);  // Always end with the LED off
}
#endif

//+=============================================================================
//
#if DECODE_HEATER
bool  IRrecv::decodeHeater (decode_results *results)
{
	bool           firstHalf = 0;  // The first half of a difference pair
	unsigned long  data      = 0;  // Somewhere to build our code
	int            offset    = 1;  // Skip the Gap reading

	// Check we have the right amount of data
	if (irparams.rawlen != (HEATER_BITS<<1))  return false ; //1 + 23

	// Read the bits in
	for (int i = 0;  i < HEATER_BITS - 1;  i++) {
		if      HEATER_GOT_ONE   firstHalf = 1 ;
		else if HEATER_GOT_ZERO  firstHalf = 0 ;
		else                     return false ;
		offset++;

		// IR data is big-endian, so we shuffle it in from the right:
		if      (HEATER_GOT_ZERO && firstHalf == 1)  data = (data << 1) | 1 ;
		else if (HEATER_GOT_ONE  && firstHalf == 0)  data = (data << 1) | 0 ;
		else                                         return false ;
		offset++;
	}

	if      HEATER_GOT_ONE   data = (data << 1) | 1 ;
	else if HEATER_GOT_ZERO  data = (data << 1) | 0 ;
	else                     return false ;

	// Success
	results->bits        = HEATER_BITS;
	results->value       = data;
	results->decode_type = HEATER;
	return true;
}
#endif
