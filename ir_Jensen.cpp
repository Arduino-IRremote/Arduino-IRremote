#include "IRremote.h"
#include "IRremoteInt.h"

// Reverse engineered by looking at RAW dumps generated by IRremote

//==============================================================================
//                   JJJJJ  EEEEE  N   N   SSSS  EEEEE  N   N
//                     J    E      NN  N  S      E      NN  N
//                     J    EEE    N N N   SSS   EEE    N N N
//                   J J    E      N  NN      S  E      N  NN
//                    J     EEEEE  N   N  SSSS   EEEEE  N   N
//==============================================================================
// Added by Adam L. Humphreys

#define JENSEN_BITS          20  // The number of bits in the command

#define JENSEN_HDR_MARK    4500  // The length of the Header:Mark
#define JENSEN_HDR_SPACE   4500  // The lenght of the Header:Space

#define JENSEN_BIT_MARK    550   // The length of a Bit:Mark
#define JENSEN_ONE_SPACE   1650  // The length of a Bit:Space for 1's
#define JENSEN_ZERO_SPACE  550   // The length of a Bit:Space for 0's

//+=============================================================================
//
#if SEND_JENSEN
void  IRsend::sendJensen (unsigned long data,  int nbits)
{
	// Delay of ~24ms between sends.

	// Set IR carrier frequency
	enableIROut(38);

	// Header
	mark (JENSEN_HDR_MARK);
	space(JENSEN_HDR_SPACE);

	// Data
	for (unsigned long  mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
		if (data & mask) {
			mark (JENSEN_BIT_MARK);
			space(JENSEN_ONE_SPACE);
		} else {
			mark (JENSEN_BIT_MARK);
			space(JENSEN_ZERO_SPACE);
		}
	}

	// Footer
	mark(JENSEN_BIT_MARK);
    space(0);  // Always end with the LED off
}
#endif

//+=============================================================================
//
#if DECODE_JENSEN
bool  IRrecv::decodeJensen (decode_results *results)
{
	unsigned long  data   = 0;  // Somewhere to build our code
	int            offset = 1;  // Skip the Gap reading

	// Check we have the right amount of data.
	if (irparams.rawlen != 1 + 2 + (2 * JENSEN_BITS) + 1)  return false ;

	// Check initial Mark+Space match. Do not use "[offset++]" or the macros will not function correctly.
	if (!MATCH_MARK (results->rawbuf[offset], JENSEN_HDR_MARK ))  return false ;
	offset++;
	if (!MATCH_SPACE(results->rawbuf[offset], JENSEN_HDR_SPACE))  return false ;
	offset++;

	// Read the bits in
	for (int i = 0;  i < JENSEN_BITS;  i++) {
		// Each bit looks like: MARK + SPACE_1 -> 1
		//                 or : MARK + SPACE_0 -> 0
		if (!MATCH_MARK(results->rawbuf[offset], JENSEN_BIT_MARK))  return false ;
		offset++;

		// IR data is big-endian, so we shuffle it in from the right:
		if      (MATCH_SPACE(results->rawbuf[offset], JENSEN_ONE_SPACE))   data = (data << 1) | 1 ;
		else if (MATCH_SPACE(results->rawbuf[offset], JENSEN_ZERO_SPACE))  data = (data << 1) | 0 ;
		else                                                               return false ;
		offset++;
	}

	// Success
	results->bits        = JENSEN_BITS;
	results->value       = data;
	results->decode_type = JENSEN;
	return true;
}
#endif
