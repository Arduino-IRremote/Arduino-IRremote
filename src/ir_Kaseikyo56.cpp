// This file was generated by IrpTransmogrifier version 0.2.1dev by bengt
// on Mon Oct 23 11:40:31 CEST 2017
// using command line arguments:
// "-c /home/bengt/harctoolbox/IrpTransmogrifier/tools/../src/main/resources/IrpProtocols.xml --url --loglevel info --logformat %5$s%n code -s src/main/st --dir ../Arduino-IRremote-bm/src -t irremote-renderer-cppsymbols -t irremote-renderer-declarations -t irremote-renderer-code Kaseikyo56".


#include "IRremote.h"
/*
IRP: 
{37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,H:4,D:4,S:8,E:8,F:8,G:8,1,-173)*{H=((M^N)::4)^(M^N),chksum=S^G^F^(E*16)^D,C=chksum::4^chksum}[D:0..15,S:0..255,F:0..255,G:0..255,M:0..255,N:0..255,E:0..255]
*/

/*
Protocol documentation:
Kaseikyo56 is a lengthened version of the Kaseikyo family of protocols. It has the same OEM codes indicating the same manufacturers as Kaseikyo, and it has the same variation (by manufacturer) in check byte and other details as Kaseikyo.
*/

#if SEND_KASEIKYO56

extern unsigned int finiteBitField(unsigned int data,
        unsigned int width,
        unsigned int chop,
        bool complement,
        bool reverse);
extern unsigned int bitCount(unsigned int data);
extern unsigned int bitReverse(unsigned int data, unsigned int width);


static inline void flash(IRsend* instance, unsigned int d) {
    instance->mark(d);
}

static inline void gap(IRsend* instance, unsigned int d) {
    instance->space(d);
}



static void bitField(IRsend* instance, unsigned int data, unsigned int width) {
    for (unsigned int i = 0; i < width; i++) {
        switch(((unsigned int)data >> i) & 1) {
        case 0: {
            flash(instance, 432);
            gap(instance, 432);
        }
        break;
        case 1: {
            flash(instance, 432);
            gap(instance, 1296);
        }
        break;
        }
    }
}
// Local functions; corresponds to Definitions in the IRP.
static inline unsigned int H(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int G,
        unsigned int M,
        unsigned int N,
        unsigned int E) {
    return ((((M)^(N)) >> (4U)))^((M)^(N));
}

static inline unsigned int chksum(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int G,
        unsigned int M,
        unsigned int N,
        unsigned int E) {
    return ((((S)^(G))^(F))^((E) * (16U)))^(D);
}

static inline unsigned int C(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int G,
        unsigned int M,
        unsigned int N,
        unsigned int E) {
    return (((chksum(D, S, F, G, M, N, E)) >> (4U)))^(chksum(D, S, F, G, M, N, E));
}

/**
 * Function for sending one signal from the protcol Kaseikyo56.
 * @param D Protocol parameter in the interval [0 .. 15].
 * @param S Protocol parameter in the interval [0 .. 255].
 * @param F Protocol parameter in the interval [0 .. 255].
 * @param G Protocol parameter in the interval [0 .. 255].
 * @param M Protocol parameter in the interval [0 .. 255].
 * @param N Protocol parameter in the interval [0 .. 255].
 * @param E Protocol parameter in the interval [0 .. 255].
 */
void IRsend::sendKaseikyo56(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int G,
        unsigned int M,
        unsigned int N,
        unsigned int E) {
    enableIROut(37000U / 1000U);
    IRsend* instance = this;
    flash(instance, 3456);
    gap(instance, 1728);
    bitField(instance, M, 8U);
    bitField(instance, N, 8U);
    bitField(instance, H(D, S, F, G, M, N, E), 4U);
    bitField(instance, D, 4U);
    bitField(instance, S, 8U);
    bitField(instance, E, 8U);
    bitField(instance, F, 8U);
    bitField(instance, G, 8U);
    flash(instance, 432);
    gap(instance, 74736);
}

#endif // SEND_KASEIKYO56 
