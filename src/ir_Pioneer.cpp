// This file was generated by IrpTransmogrifier version 0.2.1dev by bengt
// on Mon Oct 23 11:43:19 CEST 2017
// using command line arguments:
// "-c /home/bengt/harctoolbox/IrpTransmogrifier/tools/../src/main/resources/IrpProtocols.xml --url --loglevel info --logformat %5$s%n code -s src/main/st --dir ../Arduino-IRremote-bm/src -t irremote-renderer-cppsymbols -t irremote-renderer-declarations -t irremote-renderer-code Pioneer".


#include "IRremote.h"
/*
IRP: 
{40k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)*[D:0..255,S:0..255=255-D,F:0..255]
*/

/*
Protocol documentation:
Pioneer is distinguished from NEC2 only by frequency. So if your learning system does not learn frequency accurately, it won't accurately distinguish Pioneer from NEC2. All Pioneer signals should have a device number in the range 160 to 175 and no subdevice. No NEC2 signal should fit those rules. So you usually can determine whether the decision (by frequency) was wrong by checking the device numbers. Many Pioneer commands are sent as combinations of two different Pioneer signals. This version of DecodeIr does not associate the two signals together into one command. It decodes them separately. If you get more than one of the same OBC from decoding a learned signal, that just means the learning system failed to understand the repeat pattern. It does not mean a two part signal. But if there are two different OBCs (with the same or different device numbers) you have a two part Pioneer signal.
*/

#if SEND_PIONEER

extern unsigned int finiteBitField(unsigned int data,
        unsigned int width,
        unsigned int chop,
        bool complement,
        bool reverse);
extern unsigned int bitCount(unsigned int data);
extern unsigned int bitReverse(unsigned int data, unsigned int width);

static unsigned long durationCounter = 0UL;

static inline void flash(IRsend* instance, unsigned int d) {
    instance->mark(d);
    durationCounter += (unsigned long) d;
}

static inline void gap(IRsend* instance, unsigned int d) {
    instance->space(d);
    durationCounter += (unsigned long) d;
}

static inline void extent(IRsend* instance, unsigned long d) {
    instance->space((unsigned int)(d - durationCounter));
    durationCounter = 0UL;
}

static void bitField(IRsend* instance, unsigned int data, unsigned int width) {
    for (unsigned int i = 0; i < width; i++) {
        switch(((unsigned int)data >> i) & 1) {
        case 0: {
            flash(instance, 564);
            gap(instance, 564);
        }
        break;
        case 1: {
            flash(instance, 564);
            gap(instance, 1692);
        }
        break;
        }
    }
}
/**
 * Function for sending one signal from the protcol Pioneer.
 * @param D Protocol parameter in the interval [0 .. 255].
 * @param S Protocol parameter in the interval [0 .. 255].
 * @param F Protocol parameter in the interval [0 .. 255].
 */
void IRsend::sendPioneer(unsigned int D,
        unsigned int S,
        unsigned int F) {
    enableIROut(40000U / 1000U);
    IRsend* instance = this;
    durationCounter = 0UL;
    flash(instance, 9024);
    gap(instance, 4512);
    bitField(instance, D, 8U);
    bitField(instance, S, 8U);
    bitField(instance, F, 8U);
    bitField(instance, ~F, 8U);
    flash(instance, 564);
    extent(instance, 108000UL);
}

#endif // SEND_PIONEER 
