// This file was generated by IrpTransmogrifier version 0.2.1dev by bengt
// on Mon Oct 23 11:40:21 CEST 2017
// using command line arguments:
// "-c /home/bengt/harctoolbox/IrpTransmogrifier/tools/../src/main/resources/IrpProtocols.xml --url --loglevel info --logformat %5$s%n code -s src/main/st --dir ../Arduino-IRremote-bm/src -t irremote-renderer-cppsymbols -t irremote-renderer-declarations -t irremote-renderer-code JVC{2}".


#include "IRremote.h"
/*
IRP: 
{37.9k,527,33%}<1,-1|1,-3>(D:8,F:8,1,^46.42m)*[D:0..255,F:0..255]
*/

/*
Protocol documentation:
JVC{2} indicates a JVC signal from which the lead-in is missing. The JVC protocol has lead-in on only the first frame, so it is quite easy to have it missing from a learned signal. So when JVC{2} is correct, it means the same as JVC. But JVC{2} is not robust, so spurious decodes are likely. It is also very similar in structure and timing to Mitsubishi protocol, so that DecodeIr has difficulty distinguishing one from the other. The device number, OBC and EFC are all encoded the same way between the two. So if you have JVC{2} decodes that you have reason to suspect should actually be Mitsubishi, you can try using them as Mitsubishi without changing the numbers. However, true Mitsubishi signals will not misdecode as JVC, just as JVC{2}. So if some of the signals for your device decode as JVC and others as JVC{2}, you should trust all those decodes and not try Mitsubishi. Documentation by JVC.
*/

#if SEND_JVC2

extern unsigned int finiteBitField(unsigned int data,
        unsigned int width,
        unsigned int chop,
        bool complement,
        bool reverse);
extern unsigned int bitCount(unsigned int data);
extern unsigned int bitReverse(unsigned int data, unsigned int width);

static unsigned long durationCounter = 0UL;

static inline void flash(IRsend* instance, unsigned int d) {
    instance->mark(d);
    durationCounter += (unsigned long) d;
}

static inline void gap(IRsend* instance, unsigned int d) {
    instance->space(d);
    durationCounter += (unsigned long) d;
}

static inline void extent(IRsend* instance, unsigned long d) {
    instance->space((unsigned int)(d - durationCounter));
    durationCounter = 0UL;
}

static void bitField(IRsend* instance, unsigned int data, unsigned int width) {
    for (unsigned int i = 0; i < width; i++) {
        switch(((unsigned int)data >> i) & 1) {
        case 0: {
            flash(instance, 527);
            gap(instance, 527);
        }
        break;
        case 1: {
            flash(instance, 527);
            gap(instance, 1581);
        }
        break;
        }
    }
}
/**
 * Function for sending one signal from the protcol JVC2.
 * @param D Protocol parameter in the interval [0 .. 255].
 * @param F Protocol parameter in the interval [0 .. 255].
 */
void IRsend::sendJVC2(unsigned int D,
        unsigned int F) {
    enableIROut(37900U / 1000U);
    IRsend* instance = this;
    durationCounter = 0UL;
    bitField(instance, D, 8U);
    bitField(instance, F, 8U);
    flash(instance, 527);
    extent(instance, 46420UL);
}

#endif // SEND_JVC2 
