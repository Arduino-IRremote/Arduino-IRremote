// This file was generated by IrpTransmogrifier version 0.2.1dev by bengt
// on Mon Oct 23 11:40:26 CEST 2017
// using command line arguments:
// "-c /home/bengt/harctoolbox/IrpTransmogrifier/tools/../src/main/resources/IrpProtocols.xml --url --loglevel info --logformat %5$s%n code -s src/main/st --dir ../Arduino-IRremote-bm/src -t irremote-renderer-cppsymbols -t irremote-renderer-declarations -t irremote-renderer-code Kaseikyo".


#include "IRremote.h"
/*
IRP: 
{37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,E:4,C:4,1,-173)*{X=((M^N)::4)^(M^N),chksum=D^S^F^(E*16),C=chksum::4^chksum}[D:0..15,S:0..255,F:0..255,E:0..15,M:0..255,N:0..255]
*/

/*
Protocol documentation:
This is the nominal form of the Kaseikyo. It is most commonly seen with OEM codes 170.90, which indicates \"Sharp\". I assume (haven't tested) that the SharpDVD protocol in KM generates these Kaseikyo-170-90 signals. We have also seen this protocol with OEM codes 3.32. I'm not sure what manufacturer that indicates. The Kaseikyo protocol in KM seems to be designed to produce this nominal form of Kaseikyo for any specified OEM codes and any constant value of E. That should be the way to reproduce any Kaseikyo-???-??? decode other than SharpDVD, and might be better than SharpDVD for the Kaseikyo-170-90 signals.
*/

#if SEND_KASEIKYO

extern unsigned int finiteBitField(unsigned int data,
        unsigned int width,
        unsigned int chop,
        bool complement,
        bool reverse);
extern unsigned int bitCount(unsigned int data);
extern unsigned int bitReverse(unsigned int data, unsigned int width);


static inline void flash(IRsend* instance, unsigned int d) {
    instance->mark(d);
}

static inline void gap(IRsend* instance, unsigned int d) {
    instance->space(d);
}



static void bitField(IRsend* instance, unsigned int data, unsigned int width) {
    for (unsigned int i = 0; i < width; i++) {
        switch(((unsigned int)data >> i) & 1) {
        case 0: {
            flash(instance, 432);
            gap(instance, 432);
        }
        break;
        case 1: {
            flash(instance, 432);
            gap(instance, 1296);
        }
        break;
        }
    }
}
// Local functions; corresponds to Definitions in the IRP.
static inline unsigned int X(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int E,
        unsigned int M,
        unsigned int N) {
    return ((((M)^(N)) >> (4U)))^((M)^(N));
}

static inline unsigned int chksum(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int E,
        unsigned int M,
        unsigned int N) {
    return (((D)^(S))^(F))^((E) * (16U));
}

static inline unsigned int C(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int E,
        unsigned int M,
        unsigned int N) {
    return (((chksum(D, S, F, E, M, N)) >> (4U)))^(chksum(D, S, F, E, M, N));
}

/**
 * Function for sending one signal from the protcol Kaseikyo.
 * @param D Protocol parameter in the interval [0 .. 15].
 * @param S Protocol parameter in the interval [0 .. 255].
 * @param F Protocol parameter in the interval [0 .. 255].
 * @param E Protocol parameter in the interval [0 .. 15].
 * @param M Protocol parameter in the interval [0 .. 255].
 * @param N Protocol parameter in the interval [0 .. 255].
 */
void IRsend::sendKaseikyo(unsigned int D,
        unsigned int S,
        unsigned int F,
        unsigned int E,
        unsigned int M,
        unsigned int N) {
    enableIROut(37000U / 1000U);
    IRsend* instance = this;
    flash(instance, 3456);
    gap(instance, 1728);
    bitField(instance, M, 8U);
    bitField(instance, N, 8U);
    bitField(instance, X(D, S, F, E, M, N), 4U);
    bitField(instance, D, 4U);
    bitField(instance, S, 8U);
    bitField(instance, F, 8U);
    bitField(instance, E, 4U);
    bitField(instance, C(D, S, F, E, M, N), 4U);
    flash(instance, 432);
    gap(instance, 74736);
}

#endif // SEND_KASEIKYO 
