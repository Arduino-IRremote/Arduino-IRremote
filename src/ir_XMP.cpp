// This file was generated by IrpTransmogrifier version 0.2.1dev by bengt
// on Mon Oct 23 11:47:15 CEST 2017
// using command line arguments:
// "-c /home/bengt/harctoolbox/IrpTransmogrifier/tools/../src/main/resources/IrpProtocols.xml --url --loglevel info --logformat %5$s%n code -s src/main/st --dir ../Arduino-IRremote-bm/src -t irremote-renderer-cppsymbols -t irremote-renderer-declarations -t irremote-renderer-code XMP".


#include "IRremote.h"
/*
IRP: 
{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,-80.4m){C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+F+F::4+F::8+F::12)}[F:0..65535,D:0..255,S:0..255,OEM:0..255=68]
*/

/*
Protocol documentation:
The Device code is D, the SubDevice code is S and there are two OBC values. OBC1 is the high byte of F, OBC2 is the low byte of F. The OEM code is normally 0x44 and is reported in the Misc field only if it has a different value. The XMP-1 protocol is XMP with OBC2 = 0. The OBC field in DecodeIR then shows OBC1. The XMP-2 protocol is XMP with OBC1 = 0. The OBC field in DecodeIR then shows OBC2. This protocol has a 4-bit toggle T that is 0 for the first frame and normally 8 for all repeat frames. There is, however, a variant in which a further frame with T=9 is sent after the button is released, separated from the preceding frame by the short leadout of 13.8m that is used between two half-frames rather than the long lead-out of 80.4m used at the end of all other frames. When this frame is detected then the Misc field displays \"With Final Frame\". For this to be shown in a learned signal, the button must be released before the learning process times out, so a short button press is needed. These are problem decodes because JP1 remotes don\"t typically learn these signals accurately enough for a correct decode. NG Prontos also do a rotten job of learning these signals. Older Prontos seem to do fairly well. DecodeIR v2.40 includes algorithms that attempt to reconstruct a valid XMP signal from a corrupt learn, but it is impossible to correct all learning errors and there can be no certainty that a reconstruction is actually correct. In a correctly learned or fully reconstructed signal there will be an \"XMP\", \"XMP-1\" or \"XMP-2\" decode with device, subdevice and OBC values that can be used with RemoteMaster or any similar program to regenerate a clean signal. The Misc field shows which algorithms, if any, have been applied, as a list in brackets after any decode data in this field. There are notes below on the reliability of the various algorithms. When the protocol shows as (unqualified) XMP, both OBC values are non-zero. The OBC and Hex fields show OBC1. The corresponding values for OBC2 are shown in the Misc field. The learned signal itself will certainly not be valid if any reconstruction algorithms have been applied and it may not be so even if it has been decoded without reconstruction. The possible algorithm indicators in the Misc field are as follows: End (= Endpoint): The lead-out burst is missing and has been inserted. This is almost certainly correct. Rec (= Recovery): Look-ahead has been used to recover a missing burst from the following repeat frame. This is very likely to be correct. Cor (= Correction): Two bursts have been coalesced in the learning process, e.g. those for hex digits C and D, causing a C to appear as D or vice versa. The error has been identified and corrected. This is probably correct. Cal (= Calculated): A missing digit has been calculated from a checksum. The digit is probably correct but it may be in the wrong place. The most likely error in the reconstruction is that the two digits of the OBC are the wrong way round. Cal2 (= Calculated 2) Two consecutive missing zero digits have been identified, corresponding to a zero OBC. When this happens, the signal will always be shown as XMP-1. The most likely error in the reconstruction is that it should actually be XMP-2. If a learned signal is good enough to be recognised as XMP but not good enough to be fully reconstructed, the protocol will display with a name of the form XMP:136.218-0F0F441A0A800F00 In IR.exe you'll need to widen the Protocol column to see the whole thing. This represents intermediate data from an unsuccessful attempt to decode a XMP signal. The number in the position where the 136 is in this example represents the time scale. A number (like this example) that is near 137 is reasonable. A number much further from 137 indicates a more serious learning or decoding problem. The number in the position where the .218 is in this example (it is not part of the 136) represents the level of inconsistency in the individual hex digit decodes. A value greater than .100 means the hex digits aren't very reliable. The hex string, where the 0F0F441A0A800F00 is, is the decoded data. At least one digit is almost certainly wrong or the whole decode wouldn't be displayed in this form. With a JP1 learning remote, the most common errors are that a digit is actually missing, in which case the string will have fewer than 16 hex digits, or that two or more digits which are decoded the same are actually different, so some of them are correct and some are one value higher or lower. Although the reconstruction algorithms attempt to correct these types of errors, it is not always possible. In this example I happen to know the correct signal. One of the three F's is really an E and one of the two A's is really a 9. The correct string is 0E0F441A09800F00. Almost all examples we've seen start with \"0E0F441A0\" or \"060F44120\". But we've also seen upgrades from UEI for \"0D1F441A0\" and \"0C2F441A0\" and \"0B3F441A0\". The last 4 digits of the whole 16 digit string (if they are correct) represent the Hex command needed to reproduce the signal in a JP1 upgrade or KeyMove. DecodeIR shows them as two 8-bit OBC values, as described with the IRP notation above.
*/

#if SEND_XMP

extern unsigned int finiteBitField(unsigned int data,
        unsigned int width,
        unsigned int chop,
        bool complement,
        bool reverse);
extern unsigned int bitCount(unsigned int data);
extern unsigned int bitReverse(unsigned int data, unsigned int width);


static inline void flash(IRsend* instance, unsigned int d) {
    instance->mark(d);
}

static inline void gap(IRsend* instance, unsigned int d) {
    instance->space(d);
}



static void bitField(IRsend* instance, unsigned int data, unsigned int width) {
    static unsigned int pendingBits = 0U;
    static unsigned int pendingData = 0U;
    if (pendingBits > 0U) {
        // This code is valid for msb-first only
        data &= (1U << width) - 1U;
        data |= pendingData << width;
        width += pendingBits;
        pendingBits = 0U;
    }
    if (width % 4U != 0U) {
        pendingData = data;
        pendingBits = width;
        width = 0U;
    }
    for (unsigned int i = 0; i < width; i += 4) {
        switch(((unsigned int)data >> (width - i - 4)) & 15) {
        case 0: {
            flash(instance, 210);
            gap(instance, 760);
        }
        break;
        case 1: {
            flash(instance, 210);
            gap(instance, 896);
        }
        break;
        case 2: {
            flash(instance, 210);
            gap(instance, 1032);
        }
        break;
        case 3: {
            flash(instance, 210);
            gap(instance, 1168);
        }
        break;
        case 4: {
            flash(instance, 210);
            gap(instance, 1304);
        }
        break;
        case 5: {
            flash(instance, 210);
            gap(instance, 1449);
        }
        break;
        case 6: {
            flash(instance, 210);
            gap(instance, 1576);
        }
        break;
        case 7: {
            flash(instance, 210);
            gap(instance, 1712);
        }
        break;
        case 8: {
            flash(instance, 210);
            gap(instance, 1848);
        }
        break;
        case 9: {
            flash(instance, 210);
            gap(instance, 1984);
        }
        break;
        case 10: {
            flash(instance, 210);
            gap(instance, 2120);
        }
        break;
        case 11: {
            flash(instance, 210);
            gap(instance, 2256);
        }
        break;
        case 12: {
            flash(instance, 210);
            gap(instance, 2392);
        }
        break;
        case 13: {
            flash(instance, 210);
            gap(instance, 2528);
        }
        break;
        case 14: {
            flash(instance, 210);
            gap(instance, 2664);
        }
        break;
        case 15: {
            flash(instance, 210);
            gap(instance, 2800);
        }
        break;
        }
    }
}
// Local functions; corresponds to Definitions in the IRP.
static inline unsigned int C1(unsigned int F,
        unsigned int D,
        unsigned int S,
        unsigned int OEM,
        unsigned int T) {
    return -(((((((S) + (((S) >> (4U)))) + (15U)) + (OEM)) + (((OEM) >> (4U)))) + (D)) + (((D) >> (4U))));
}

static inline unsigned int C2(unsigned int F,
        unsigned int D,
        unsigned int S,
        unsigned int OEM,
        unsigned int T) {
    return -(((((((S) + (((S) >> (4U)))) + (T)) + (F)) + (((F) >> (4U)))) + (((F) >> (8U)))) + (((F) >> (12U))));
}

/**
 * Function for sending one signal from the protcol XMP.
 * @param F Protocol parameter in the interval [0 .. 65535].
 * @param D Protocol parameter in the interval [0 .. 255].
 * @param S Protocol parameter in the interval [0 .. 255].
 * @param OEM Protocol parameter in the interval [0 .. 255].
 */
void IRsend::sendXMP(unsigned int F,
        unsigned int D,
        unsigned int S,
        unsigned int OEM) {
    enableIROut(38000U / 1000U);
    IRsend* instance = this;
    unsigned int T;
    T = 0U;
    bitField(instance, S >> (4U), 4U);
    bitField(instance, C1(F, D, S, OEM, T), 4U);
    bitField(instance, S, 4U);
    bitField(instance, 15U, 4U);
    bitField(instance, OEM, 8U);
    bitField(instance, D, 8U);
    flash(instance, 210);
    gap(instance, 13800);
    bitField(instance, S >> (4U), 4U);
    bitField(instance, C2(F, D, S, OEM, T), 4U);
    bitField(instance, T, 4U);
    bitField(instance, S, 4U);
    bitField(instance, F, 16U);
    flash(instance, 210);
    gap(instance, 80400);
}

#endif // SEND_XMP 
